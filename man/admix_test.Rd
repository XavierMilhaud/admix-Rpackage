% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/admix_test.R
\name{admix_test}
\alias{admix_test}
\title{Equality test for the unknown components of admixture models}
\usage{
admix_test(
  samples,
  admixMod,
  test_method = c("poly", "icv"),
  sim_U = NULL,
  n_sim_tab = 50,
  ICV_tunePenalty = TRUE,
  ask_poly_param = FALSE,
  support = c("Real", "Integer", "Positive", "Bounded.continuous"),
  conf_level = 0.95,
  parallel = FALSE,
  n_cpu = 2
)
}
\arguments{
\item{samples}{(list) A list of the K (K>0) samples to be studied, each one assumed to follow a mixture distributions.}

\item{admixMod}{(list) A list of objects of class 'admix_model', containing useful information about distributions and parameters.}

\item{test_method}{The testing method to be applied. Can be either 'poly' (polynomial basis expansion) or 'icv' (inner
convergence from IBM). The same testing method is performed between all samples. In the one-sample case,
only 'Poly' is available and the test is a gaussianity test. For further details, see section 'Details' below.}

\item{sim_U}{(Only with 'icv' testing method, otherwise useless) Random draws of the inner convergence part of the contrast
as defined in the IBM approach (see 'Details' below).}

\item{n_sim_tab}{(Only with 'icv' testing method, otherwise useless) Number of simulated gaussian processes used in the
tabulation of the inner convergence distribution in the IBM approach.}

\item{ICV_tunePenalty}{(Only with 'icv' testing method, otherwise useless. Default to TRUE) Boolean used to tune the penalty term in the
k-sample test (k=2,3,...,K) when using Inversion Best Matching (IBM) approach coupled to Inner ConVergence (icv)
property. Particularly useful when studying unbalanced samples (in terms of sample size) or small-sized samples.}

\item{ask_poly_param}{(Only with 'poly' testing method, otherwise useless. Boolean, default to FALSE) If TRUE, ask the user to choose
both the order 'K' of expansion coefficients in the orthonormal polynomial basis, and the penalization rate 's'
involved on the penalization rule for the test. Default values for these two parameters are 'K=3' and 's=0.25'.}

\item{support}{(Used with 'poly' testing method, otherwise useless) The support of the observations; one of "Real",
"Integer", "Positive", or "Bounded.continuous".}

\item{conf_level}{The confidence level of the K-sample test.}

\item{parallel}{(default to FALSE) Boolean indicating whether parallel computations are performed (speed-up the tabulation).}

\item{n_cpu}{(default to 2) Number of cores used when parallelizing.}
}
\value{
A list containing the decision of the test (reject or not), the confidence level at which the test is performed,
the p-value of the test, and the value of the test statistic (following a chi2 distribution with one degree of freedom
under the null).
}
\description{
Perform hypothesis test between unknown components of a list of admixture models, where we remind that the i-th admixture
model has probability density function (pdf) l_i such that:
l_i = p_i * f_i + (1-p_i) * g_i, with g_i the known component density.
The unknown quantities p_i and f_i are thus estimated, leading to the test given by the following null and alternative hypothesis:
H0: f_i = f_j for all i != j   against H1 : there exists at least i != j such that f_i differs from f_j.
The test can be performed using two methods, either the comparison of coefficients obtained through polynomial basis expansions
of the component densities, or by the inner-convergence property obtained using the IBM approach. See 'Details' below for further information.
}
\details{
For further details on hypothesis tests, see i) Inner convergence through IBM approach ; ii) Polynomial expansions.
.
}
\examples{
####### Example with 1 sample (gaussianity test):
mixt1 <- twoComp_mixt(n = 450, weight = 0.4,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(c("mean" = -2, "sd" = 0.5),
                                        c("mean" = 0, "sd" = 1)))
data1 <- getmixtData(mixt1)
admixMod <- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admix_test(samples = list(data1), admixMod = list(admixMod),
           test_method = "poly", ask_poly_param = FALSE, support = "Real",
           conf_level = 0.95, parallel = FALSE, n_cpu = 2)

####### Example with 2 samples
mixt1 <- twoComp_mixt(n = 450, weight = 0.4,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(c("mean" = -2, "sd" = 0.5),
                                        c("mean" = 0, "sd" = 1)))
mixt2 <- twoComp_mixt(n = 450, weight = 0.24,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(c("mean" = -2, "sd" = 0.5),
                                        c("mean" = -1, "sd" = 1)))
data1 <- getmixtData(mixt1)
data2 <- getmixtData(mixt2)
admixMod1 <- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 <- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
admix_test(samples = list(data1,data2), admixMod = list(admixMod1,admixMod2),
           test_method = "poly", ask_poly_param = FALSE, support = "Real",
           conf_level = 0.95, parallel = FALSE, n_cpu = 2)

####### Example with 3 samples
mixt1 <- twoComp_mixt(n = 450, weight = 0.4,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(c("mean" = -2, "sd" = 0.5),
                                        c("mean" = 0, "sd" = 1)))
mixt2 <- twoComp_mixt(n = 600, weight = 0.24,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(c("mean" = -2, "sd" = 0.5),
                                        c("mean" = -1, "sd" = 1)))
mixt3 <- twoComp_mixt(n = 400, weight = 0.53,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(c("mean" = -2, "sd" = 0.5),
                                        c("mean" = 2, "sd" = 1)))
data1 <- getmixtData(mixt1)
data2 <- getmixtData(mixt2)
data3 <- getmixtData(mixt3)
admixMod1 <- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 <- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
admixMod3 <- admix_model(knownComp_dist = mixt3$comp.dist[[2]],
                         knownComp_param = mixt3$comp.param[[2]])

admix_test(samples = list(data1, data2, data3),
           admixMod = list(admixMod1, admixMod2, admixMod3),
           test_method = "icv", n_sim_tab = 10, ICV_tunePenalty = FALSE,
           conf_level = 0.95, parallel = FALSE, n_cpu = 2)

}
\references{
\insertRef{MilhaudPommeretSalhiVandekerkhove2024a}{admix}
\insertRef{MilhaudPommeretSalhiVandekerkhove2022}{admix}
\insertRef{PommeretVandekerkhove2019}{admix}
}
\author{
Xavier Milhaud \href{mailto:xavier.milhaud.research@gmail.com}{xavier.milhaud.research@gmail.com}
}
