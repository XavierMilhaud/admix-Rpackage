<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Hypothesis test in admixture models • admix</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Hypothesis test in admixture models">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">admix</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.3.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/admixture-clustering.html">Clustering of unknown subpopulations in admixture models</a></li>
    <li><a class="dropdown-item" href="../articles/admixture-weight-estimation.html">Estimation of unknown elements in admixture models</a></li>
    <li><a class="dropdown-item" href="../articles/test-hypothesis.html">Hypothesis test in admixture models</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/XavierMilhaud/admix-Rpackage/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Hypothesis test in admixture models</h1>
                        <h4 data-toc-skip class="author">Xavier
Milhaud</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/XavierMilhaud/admix-Rpackage/blob/main/vignettes/test-hypothesis.Rmd" class="external-link"><code>vignettes/test-hypothesis.Rmd</code></a></small>
      <div class="d-none name"><code>test-hypothesis.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/XavierMilhaud/admix-Rpackage" class="external-link">admix</a></span><span class="op">)</span></span></code></pre></div>
<p>We remind that a random variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
following an admixture distribution has cumulative distribution function
(cdf)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>p</mi><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>G</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="2.0em"></mspace><mi>x</mi><mo>∈</mo><mi>ℝ</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">L(x) = pF(x) + (1-p)G(x), \qquad x \in \mathbb{R},</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
is a mixture component whose distribution is perfectly known, whereas
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
are unknown. In this setting, if no parametric assumption is made on the
unknown component distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>,
the mixture is considered as a semiparametric mixture. For an overview
on semiparametric extensions of finite mixture models, see <span class="citation">(Xiang and Yang 2018)</span>.</p>
<p>The goal of this vignette is to introduce the functionalities that
enable to perform hypothesis tests on the unknown component distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>.
We aim to test whether
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
belongs to certain parametric family (e.g. the Gaussian one) in a
1-sample case, or if two different decontaminated versions of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mn>1</mn></msub><annotation encoding="application/x-tex">F_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mn>2</mn></msub><annotation encoding="application/x-tex">F_2</annotation></semantics></math>
(obtained from two observed samples
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>1</mn></msub><annotation encoding="application/x-tex">X_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>2</mn></msub><annotation encoding="application/x-tex">X_2</annotation></semantics></math>)
are similar in the K-sample case
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">K \geq 2</annotation></semantics></math>).
All the specific tests presented hereafter can be performed using one
single generic function for testing with appropriate arguments, the
so-called
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>x</mi><mi>_</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">admix\_test</annotation></semantics></math>
function.</p>
<div class="section level2">
<h2 id="the-one-sample-case-only-available-to-symmetric-unknown-density">The one-sample case only available to symmetric unknown density<a class="anchor" aria-label="anchor" href="#the-one-sample-case-only-available-to-symmetric-unknown-density"></a>
</h2>
<p>In this setting, the test to be performed is a parametric family
testing, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><mspace width="0.167em"></mspace><mi>F</mi><mo>∈</mo><mi>ℱ</mi><mspace width="2.0em"></mspace><mtext mathvariant="normal">against</mtext><mspace width="2.0em"></mspace><msub><mi>H</mi><mn>1</mn></msub><mo>:</mo><mspace width="0.167em"></mspace><mi>F</mi><mo>∉</mo><mi>ℱ</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">H_0: \, F\in \mathcal{F} \qquad \mbox{against} \qquad  H_1: \, F\notin \mathcal{F},</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℱ</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>F</mi><mi>θ</mi></msub><mo>:</mo><mspace width="0.222em"></mspace><mi>θ</mi><mo>∈</mo><mi>Θ</mi><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{F}=\left\{F_\theta:~\theta\in \Theta \right\}</annotation></semantics></math>.</p>
<p>The support of the known component density has to be in line with the
one of the unknown component density. Such tests have been introduced in
<span class="citation">(Pommeret and Vandekerkhove 2019)</span>, and the
idea underlying this hypothesis test follows these steps:</p>
<ol style="list-style-type: decimal">
<li>decompose the observed density and the known density in an
orthonormal polynomial basis,</li>
<li>get the expansion coefficients of such densities,</li>
<li>reformulate the null hypothesis of the test using these
coefficients,</li>
<li>adopt a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>χ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\chi^2</annotation></semantics></math>
test strategy that relies on Central Limit Theorem (CLT) results on
estimators of the (unknown) weight related to the unknown component
distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>.</li>
</ol>
<p>Because of the use of asymptotically normal estimators, it is not
possible to use the estimator provided in <span class="citation">(Patra
and Sen 2016)</span> to perform hypothesis testing. On the contrary,
<span class="citation">Bordes and Vandekerkhove (2010)</span> propose an
estimator that can be used if the unknown component density is assumed
to be symmetric. More generally, <span class="citation">Pommeret and
Vandekerkhove (2019)</span> give more details about the distribution of
the test statistic under the null (hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>0</mn></msub><annotation encoding="application/x-tex">H_0</annotation></semantics></math>),
and under the alternative
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>.</p>
<p>Here, the implemented function allows to perform the so-called
Gaussianity test, meaning that the parametric family against which the
unknown component is tested belongs to Gaussian distributions. Below is
an example of hypothesis testing in this 1-sample case:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">####### Under the null hypothesis H0.</span></span>
<span><span class="co">## Simulate mixture data:</span></span>
<span><span class="va">mixt1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/twoComp_mixt.html">twoComp_mixt</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">300</span>, weight <span class="op">=</span> <span class="fl">0.6</span>,</span>
<span>                      comp.dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"norm"</span>, <span class="st">"norm"</span><span class="op">)</span>,</span>
<span>                      comp.param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="fl">2</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>,</span>
<span>                                        <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="fl">0</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">data1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getmixtData.html">getmixtData</a></span><span class="op">(</span><span class="va">mixt1</span><span class="op">)</span></span>
<span><span class="co">## Define the admixture model:</span></span>
<span><span class="va">admixMod</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/admix_model.html">admix_model</a></span><span class="op">(</span>knownComp_dist <span class="op">=</span> <span class="va">mixt1</span><span class="op">$</span><span class="va">comp.dist</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>,</span>
<span>                        knownComp_param <span class="op">=</span> <span class="va">mixt1</span><span class="op">$</span><span class="va">comp.param</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/admix_test.html">admix_test</a></span><span class="op">(</span>samples <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">data1</span><span class="op">)</span>, admixMod <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">admixMod</span><span class="op">)</span>,</span>
<span>           test_method <span class="op">=</span> <span class="st">"poly"</span>, ask_poly_param <span class="op">=</span> <span class="cn">FALSE</span>, support <span class="op">=</span> <span class="st">"Real"</span>,</span>
<span>           conf_level <span class="op">=</span> <span class="fl">0.95</span>, parallel <span class="op">=</span> <span class="cn">FALSE</span>, n_cpu <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt; Call:admix_test(samples = list(data1), admixMod = list(admixMod), </span></span>
<span><span class="co">#&gt;     test_method = "poly", ask_poly_param = FALSE, support = "Real", </span></span>
<span><span class="co">#&gt;     conf_level = 0.95, parallel = FALSE, n_cpu = 2)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Do we reject the null hypothesis? No</span></span>
<span><span class="co">#&gt; Here is the associated p-value of the test: 0.916</span></span></code></pre></div>
<p>The result of the test is that we cannot reject the null hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>0</mn></msub><annotation encoding="application/x-tex">H_0</annotation></semantics></math>,
which is in line with the specified distribution for the unknown
component. Indeed, simulated data is a Gaussian mixture with two
components,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∼</mo><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>μ</mi><mo>,</mo><mi>σ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F \sim \mathcal{N}(\mu,\sigma)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\mu=2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\sigma=0.5</annotation></semantics></math>.</p>
</div>
<div class="section level2">
<h2 id="the-two-sample-case">The two-sample case<a class="anchor" aria-label="anchor" href="#the-two-sample-case"></a>
</h2>
<p>Let us introduce two random samples
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>1</mn></msub><annotation encoding="application/x-tex">X_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>2</mn></msub><annotation encoding="application/x-tex">X_2</annotation></semantics></math>
following admixture models, such that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>L</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>G</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>p</mi><mn>1</mn></msub><msub><mi>F</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>L</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>G</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>p</mi><mn>2</mn></msub><msub><mi>F</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
  \left\{
    \begin{array}{l}
        L_1(x) = (1-p_1)G_1(x) + p_1F_1(x) \\
        L_2(x) = (1-p_2)G_2(x) + p_2F_2(x),
    \end{array}
    \right.
\end{align*}</annotation></semantics></math></p>
<p>The goal here is to perform the following hypothesis test:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><mspace width="0.222em"></mspace><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><msub><mi>F</mi><mn>2</mn></msub><mspace width="2.0em"></mspace><mtext mathvariant="normal">against</mtext><mspace width="2.0em"></mspace><msub><mi>H</mi><mn>1</mn></msub><mo>:</mo><msub><mi>F</mi><mn>1</mn></msub><mo>≠</mo><msub><mi>F</mi><mn>2</mn></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">H_0: ~ F_1=F_2 \qquad \mbox{against} \qquad H_1: F_1\neq F_2.</annotation></semantics></math></p>
<div class="section level3">
<h3 id="case-of-symmetric-unknown-densities">Case of symmetric unknown densities<a class="anchor" aria-label="anchor" href="#case-of-symmetric-unknown-densities"></a>
</h3>
<p>In this framework, we assume that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mn>1</mn></msub><annotation encoding="application/x-tex">F_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mn>2</mn></msub><annotation encoding="application/x-tex">F_2</annotation></semantics></math>
both have a symmetric density. This way the normally-distributed
estimator of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mn>1</mn></msub><annotation encoding="application/x-tex">p_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mn>2</mn></msub><annotation encoding="application/x-tex">p_2</annotation></semantics></math>,
proposed in <span class="citation">(Bordes and Vandekerkhove
2010)</span>, can be used together with the testing strategy suggested
in <span class="citation">(Milhaud et al. 2022)</span>. This testing
strategy is closely connected to <span class="citation">(Pommeret and
Vandekerkhove 2019)</span>, where the computation of the expansion
coefficients is duplicated on each of the two samples under study.</p>
<p>In what follows, we simulate two samples under the null and check
whether the test provides satisfactory results.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mixt1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/twoComp_mixt.html">twoComp_mixt</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">350</span>, weight <span class="op">=</span> <span class="fl">0.8</span>,</span>
<span>                      comp.dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"norm"</span>, <span class="st">"norm"</span><span class="op">)</span>,</span>
<span>                      comp.param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="fl">3</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>,</span>
<span>                                        <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="fl">0</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">mixt2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/twoComp_mixt.html">twoComp_mixt</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">450</span>, weight <span class="op">=</span> <span class="fl">0.7</span>,</span>
<span>                      comp.dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"norm"</span>, <span class="st">"norm"</span><span class="op">)</span>,</span>
<span>                      comp.param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="fl">3</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>,</span>
<span>                                        <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="fl">6</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">1.2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">data1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getmixtData.html">getmixtData</a></span><span class="op">(</span><span class="va">mixt1</span><span class="op">)</span></span>
<span><span class="va">data2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getmixtData.html">getmixtData</a></span><span class="op">(</span><span class="va">mixt2</span><span class="op">)</span></span>
<span><span class="co">## Define the admixture models:</span></span>
<span><span class="va">admixMod1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/admix_model.html">admix_model</a></span><span class="op">(</span>knownComp_dist <span class="op">=</span> <span class="va">mixt1</span><span class="op">$</span><span class="va">comp.dist</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>,</span>
<span>                         knownComp_param <span class="op">=</span> <span class="va">mixt1</span><span class="op">$</span><span class="va">comp.param</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">admixMod2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/admix_model.html">admix_model</a></span><span class="op">(</span>knownComp_dist <span class="op">=</span> <span class="va">mixt2</span><span class="op">$</span><span class="va">comp.dist</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>,</span>
<span>                         knownComp_param <span class="op">=</span> <span class="va">mixt2</span><span class="op">$</span><span class="va">comp.param</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">## Using expansion coefficients in orthonormal polynomial basis:</span></span>
<span><span class="fu"><a href="../reference/admix_test.html">admix_test</a></span><span class="op">(</span>samples <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">data1</span>,<span class="va">data2</span><span class="op">)</span>, admixMod <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">admixMod1</span>,<span class="va">admixMod2</span><span class="op">)</span>,</span>
<span>           test_method <span class="op">=</span> <span class="st">"poly"</span>, ask_poly_param <span class="op">=</span> <span class="cn">FALSE</span>, support <span class="op">=</span> <span class="st">"Real"</span>, conf_level <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span><span class="co">#&gt; Call:admix_test(samples = list(data1, data2), admixMod = list(admixMod1, </span></span>
<span><span class="co">#&gt;     admixMod2), test_method = "poly", ask_poly_param = FALSE, </span></span>
<span><span class="co">#&gt;     support = "Real", conf_level = 0.95)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Do we reject the null hypothesis? No</span></span>
<span><span class="co">#&gt; Here is the associated p-value of the test: 0.605</span></span></code></pre></div>
<p>The hypothesis test concludes that the null hypothesis cannot be
rejected, once again in line with what was expected given the specified
parameters when simulating the data.</p>
<p>Note that the following arguments, involved in subroutines, were set
to default values (but that the user can choose them setting parameter
‘ask_poly_param’ to TRUE):</p>
<ul>
<li>‘est_method’ is set to ‘BVdk’ to tell the program to estimate the
unknown proportions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mn>1</mn></msub><annotation encoding="application/x-tex">p_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mn>2</mn></msub><annotation encoding="application/x-tex">p_2</annotation></semantics></math>
using the estimator proposed in <span class="citation">(Bordes and
Vandekerkhove 2010)</span>,</li>
<li>‘K’ equals 3 to mention that such expansions are computed up to the
third order of the decomposition in the polynomial basis,</li>
<li>‘s’ equals 0.25 as the penalization rate involved in the
penalization rule used in <span class="citation">(Milhaud et al.
2022)</span>.</li>
</ul>
<p>When the unknown component distributions are not supposed to have
symmetric densities, another solution to perform the test is to set
‘est_method’ to ‘PS’ following ‘ask_poly_param’ set to TRUE, but keeping
in mind that plugging in such estimators for the test procedure should
not be allowed in theory. However, that works quite well in practice.
Another solution to perform this test in full generality is to use the
IBM method (see below).</p>
</div>
<div class="section level3">
<h3 id="case-of-fully-unknown-densities">Case of fully unknown densities<a class="anchor" aria-label="anchor" href="#case-of-fully-unknown-densities"></a>
</h3>
<p>Estimation of the unknown quantities is made by the Inversion - Best
Matching approach, see <span class="citation">(Milhaud et al.
2024b)</span>. In this case, one can still use the function with same
first arguments except ‘method’, and ‘method’ should be set to ‘icv’.
The user also has to define the number of simulated gaussian processes
used to tabulate the test statistic distribution (‘n_sim_tab’), and can
accelerate computations using parallel computations and choosing an
adequate number of cpus. Other arguments such as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">support</annotation></semantics></math>
are useless.</p>
</div>
</div>
<div class="section level2">
<h2 id="the-k-sample-case">The K-sample case<a class="anchor" aria-label="anchor" href="#the-k-sample-case"></a>
</h2>
<p>We introduce hereafter a natural extension of the two-sample case to
the K-sample one, see <span class="citation">(Milhaud et al.
2024a)</span>. In what follows, the K-sample test is illustrated within
the framework of the IBM approach, i.e. using the associated inner
convergence property. Of course, in the case when all the unknown
component densities are assumed to be symmetric, one could use a
pairwise version of the two sample test using the comparison of
expansion coefficients in a polynomial orthonormal basis, associated to
the estimation method provided by <span class="citation">(Bordes and
Vandekerkhove 2010)</span>.</p>
<p>Consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
samples. For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">i=1,...,K</annotation></semantics></math>,
sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>X</mi><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msubsup><mi>X</mi><msub><mi>n</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X^{(i)} = (X_1^{(i)}, ..., X_{n_i}^{(i)})</annotation></semantics></math>
follows
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>p</mi><mi>i</mi></msub><msub><mi>F</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>G</mi><mi>i</mi></msub><mo>,</mo><mspace width="2.0em"></mspace><mi>x</mi><mo>∈</mo><mi>ℝ</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">L_i(x) = p_i F_i(x) + (1-p_i) G_i, \qquad x \in \mathbb{R}.</annotation></semantics></math>
The test to perform is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><mspace width="0.278em"></mspace><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>=</mo><msub><mi>F</mi><mi>K</mi></msub><mspace width="2.0em"></mspace><mtext mathvariant="normal">against</mtext><mspace width="2.0em"></mspace><msub><mi>H</mi><mn>1</mn></msub><mo>:</mo><mspace width="0.278em"></mspace><msub><mi>F</mi><mi>i</mi></msub><mo>≠</mo><msub><mi>F</mi><mi>j</mi></msub><mspace width="1.0em"></mspace><mtext mathvariant="normal">for some</mtext><mspace width="1.0em"></mspace><mi>i</mi><mo>≠</mo><mi>j</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">H_0 : \; F_1 = ... = F_K \qquad \mbox{against} \qquad H_1: \; F_i \neq F_j \quad \mbox{for some} \quad i \neq j.</annotation></semantics></math>
We use the IBM approach to do so, where assumptions are
(straightforwardly) adapted to deal with the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
samples.</p>
<p>Basically, we apply the theoretical results of IBM for each pair of
populations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math>,
and then build a series of embedded statistics.</p>
<p>Consider the set of pair indices: <span class="math inline">${\cal
S}(K) = \{(i,j)\in \mathbb{N}^2 ; \; 1\leq i&lt;j \leq K\}$</span>.\
Order <span class="math inline">${\cal S}(K)$</span> lexicographically,
and denote
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>K</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">r_K[(i,j)]</annotation></semantics></math>
the rank of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math>
in the set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>K</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">S(K)</annotation></semantics></math>.</p>
<p>Then,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>i</mi><mo>≠</mo><mi>j</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>K</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\forall i\neq j \in \{1,...,K\}</annotation></semantics></math>,</p>
<ol style="list-style-type: decimal">
<li>Estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>arg</mo><msub><mo>min</mo><mrow><mi>θ</mi><mo>∈</mo><msub><mi>Θ</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></msub><msub><mi>d</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\theta}_{n}(i,j) = \arg\min_{\theta\in \Theta_{i,j}}d_n[i,j](\theta)</annotation></semantics></math>,</li>
<li>Compute the statistic
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>n</mi><mspace width="0.167em"></mspace><msub><mi>d</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T_{i,j} = n \, d_n[i,j](\hat{\theta}_n(i,j))</annotation></semantics></math>.</li>
</ol>
<p>We then obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>K</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>K</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">d(K) = K(K-1)/2</annotation></semantics></math>
comparisons that we embed in a series of statistics:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>U</mi><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>T</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>U</mi><mn>2</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>T</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>T</mi><mrow><mn>1</mn><mo>,</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="left" style="text-align: left"></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>U</mi><mrow><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>K</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>T</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>T</mi><mrow><mi>K</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>K</mi></mrow></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray*}
    U_1 &amp;= &amp;T_{1,2} \\
    U_2 &amp; = &amp; T_{1,2}+T_{1,3} \\
        &amp;\vdots&amp; \\
    U_{d(K)} &amp; = &amp;T_{1,2} + \cdots + T_{K-1,K},
\end{eqnarray*}</annotation></semantics></math></p>
<p>To choose automatically the right order
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
for testing, consider the penalization rule (mimicking Schwarz criteria
procedure, see <span class="citation">(Schwarz 1978)</span>):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>min</mo><mrow><mo stretchy="true" form="prefix">{</mo><mo>arg</mo><munder><mo>max</mo><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>K</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></munder><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>U</mi><mi>k</mi></msub><mo>−</mo><mi>k</mi><munder><mo>∑</mo><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>K</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></munder><msub><mi>l</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><msub><mn>1</mn><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>r</mi><mi>K</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>k</mi><mo stretchy="true" form="postfix">}</mo></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">S(n) = \min \left\{\arg\max_{1 \leq k \leq d(K)} \left ({U}_{k} - k \sum_{(i,j)\in S(K)} l_n(i,j) \; 1_{\left\{r_K(i,j)=k\right\}} \right )  \right\}.</annotation></semantics></math></p>
<p>Our data-driven test statistic is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>U</mi><mo accent="true">̃</mo></mover><mi>n</mi></msub><mo>=</mo><msub><mi>U</mi><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\tilde{U}_n =  U_{S(n)}.</annotation></semantics></math></p>
<p>It can be shown that under
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>0</mn></msub><annotation encoding="application/x-tex">H_0</annotation></semantics></math>
and appropriate assumptions,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">S(n)</annotation></semantics></math>
converges in probablity towards 1 as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>→</mo><mo>+</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">n \rightarrow +\infty</annotation></semantics></math>;
meaning that we asymptotically choose the first element of <span class="math inline">${\cal S}(K)$</span>.\ Moreover, under
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>0</mn></msub><annotation encoding="application/x-tex">H_0</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub><annotation encoding="application/x-tex">U_{S(n)}</annotation></semantics></math>
converges in law towards
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>U</mi><mn>0</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">U^{0}(1,2)</annotation></semantics></math>,
which is exactly the null limit distribution studied in the two-sample
case. Finally, we thus consider the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>0</mn></msub><annotation encoding="application/x-tex">H_0</annotation></semantics></math>-rejection
rule:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>U</mi><mo accent="true">̃</mo></mover><mi>n</mi></msub><mspace width="1.0em"></mspace><mo>≥</mo><mspace width="1.0em"></mspace><msub><mover><mi>q</mi><mo accent="true">̂</mo></mover><mrow><mn>1</mn><mo>−</mo><mi>α</mi></mrow></msub><mspace width="2.0em"></mspace><mo>⇒</mo><mspace width="2.0em"></mspace><msub><mi>H</mi><mn>0</mn></msub><mspace width="0.278em"></mspace><mtext mathvariant="normal">is rejected</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">\tilde{U}_n \quad \geq \quad \hat q_{1-\alpha} \qquad \Rightarrow \qquad H_0 \; \mbox{is rejected}.</annotation></semantics></math></p>
<p>We now provide the way to perform this test with the package
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">admix</annotation></semantics></math>
with Gaussian mixtures. First, let us study the case where we are under
the null hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>0</mn></msub><annotation encoding="application/x-tex">H_0</annotation></semantics></math>,
considering
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">K=3</annotation></semantics></math>
different populations.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mixt1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/twoComp_mixt.html">twoComp_mixt</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">450</span>, weight <span class="op">=</span> <span class="fl">0.4</span>,</span>
<span>                      comp.dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"norm"</span>, <span class="st">"norm"</span><span class="op">)</span>,</span>
<span>                      comp.param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="op">-</span><span class="fl">2</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>,</span>
<span>                                        <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="fl">0</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">mixt2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/twoComp_mixt.html">twoComp_mixt</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">600</span>, weight <span class="op">=</span> <span class="fl">0.24</span>,</span>
<span>                      comp.dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"norm"</span>, <span class="st">"norm"</span><span class="op">)</span>,</span>
<span>                      comp.param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="op">-</span><span class="fl">2</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>,</span>
<span>                                        <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">mixt3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/twoComp_mixt.html">twoComp_mixt</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">400</span>, weight <span class="op">=</span> <span class="fl">0.53</span>,</span>
<span>                      comp.dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"norm"</span>, <span class="st">"norm"</span><span class="op">)</span>,</span>
<span>                      comp.param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="op">-</span><span class="fl">2</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>,</span>
<span>                                        <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean"</span> <span class="op">=</span> <span class="fl">2</span>, <span class="st">"sd"</span> <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">data1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getmixtData.html">getmixtData</a></span><span class="op">(</span><span class="va">mixt1</span><span class="op">)</span></span>
<span><span class="va">data2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getmixtData.html">getmixtData</a></span><span class="op">(</span><span class="va">mixt2</span><span class="op">)</span></span>
<span><span class="va">data3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getmixtData.html">getmixtData</a></span><span class="op">(</span><span class="va">mixt3</span><span class="op">)</span></span>
<span><span class="va">admixMod1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/admix_model.html">admix_model</a></span><span class="op">(</span>knownComp_dist <span class="op">=</span> <span class="va">mixt1</span><span class="op">$</span><span class="va">comp.dist</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>,</span>
<span>                         knownComp_param <span class="op">=</span> <span class="va">mixt1</span><span class="op">$</span><span class="va">comp.param</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">admixMod2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/admix_model.html">admix_model</a></span><span class="op">(</span>knownComp_dist <span class="op">=</span> <span class="va">mixt2</span><span class="op">$</span><span class="va">comp.dist</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>,</span>
<span>                         knownComp_param <span class="op">=</span> <span class="va">mixt2</span><span class="op">$</span><span class="va">comp.param</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">admixMod3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/admix_model.html">admix_model</a></span><span class="op">(</span>knownComp_dist <span class="op">=</span> <span class="va">mixt3</span><span class="op">$</span><span class="va">comp.dist</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>,</span>
<span>                         knownComp_param <span class="op">=</span> <span class="va">mixt3</span><span class="op">$</span><span class="va">comp.param</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/admix_test.html">admix_test</a></span><span class="op">(</span>samples <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">data1</span>, <span class="va">data2</span>, <span class="va">data3</span><span class="op">)</span>,</span>
<span>           admixMod <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">admixMod1</span>, <span class="va">admixMod2</span>, <span class="va">admixMod3</span><span class="op">)</span>,</span>
<span>           test_method <span class="op">=</span> <span class="st">"icv"</span>, n_sim_tab <span class="op">=</span> <span class="fl">8</span>, ICV_tunePenalty <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>           conf_level <span class="op">=</span> <span class="fl">0.95</span>, parallel <span class="op">=</span> <span class="cn">FALSE</span>, n_cpu <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt; Call:admix_test(samples = list(data1, data2, data3), admixMod = list(admixMod1, </span></span>
<span><span class="co">#&gt;     admixMod2, admixMod3), test_method = "icv", n_sim_tab = 8, </span></span>
<span><span class="co">#&gt;     ICV_tunePenalty = FALSE, conf_level = 0.95, parallel = FALSE, </span></span>
<span><span class="co">#&gt;     n_cpu = 2)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Do we reject the null hypothesis? No</span></span>
<span><span class="co">#&gt; Here is the associated p-value of the test: 0.625</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-BordesVandekerkhove2010" class="csl-entry">
Bordes, L., and P. Vandekerkhove. 2010. <span>“Semiparametric
Two-Component Mixture Model with a Known Component: An Asymptotically
Normal Estimator.”</span> <em>Mathematical Methods of Statistics</em> 19
(1): 22–41. https://doi.org/<a href="https://doi.org/10.3103/S1066530710010023" class="external-link">https://doi.org/10.3103/S1066530710010023</a>.
</div>
<div id="ref-MilhaudPommeretSalhiVandekerkhove2022" class="csl-entry">
Milhaud, Xavier, Denys Pommeret, Yahia Salhi, and Pierre Vandekerkhove.
2022. <span>“Semiparametric Two-Sample Admixture Components Comparison
Test: The Symmetric Case.”</span> <em>Journal of Statistical Planning
and Inference</em> 216: 135–50. https://doi.org/<a href="https://doi.org/10.1016/j.jspi.2021.05.010" class="external-link">https://doi.org/10.1016/j.jspi.2021.05.010</a>.
</div>
<div id="ref-MilhaudPommeretSalhiVandekerkhove2024b" class="csl-entry">
———. 2024a. <span>“Contamination-Source Based k-Sample
Clustering.”</span> <em>Journal of Machine Learning Research</em> 25
(287): 1–32. <a href="https://jmlr.org/papers/v25/23-0914.html" class="external-link">https://jmlr.org/papers/v25/23-0914.html</a>.
</div>
<div id="ref-MilhaudPommeretSalhiVandekerkhove2024a" class="csl-entry">
———. 2024b. <span>“<span class="nocase">Two-sample contamination model
test</span>.”</span> <em>Bernoulli</em> 30 (1): 170–97. <a href="https://doi.org/10.3150/23-BEJ1593" class="external-link">https://doi.org/10.3150/23-BEJ1593</a>.
</div>
<div id="ref-PatraSen2016" class="csl-entry">
Patra, Rohit Kumar, and Bodhisattva Sen. 2016. <span>“<span class="nocase">Estimation of a two-component mixture model with
applications to multiple testing</span>.”</span> <em>Journal of the
Royal Statistical Society Series B</em> 78 (4): 869–93.
</div>
<div id="ref-PommeretVandekerkhove2019" class="csl-entry">
Pommeret, Denys, and Pierre Vandekerkhove. 2019. <span>“Semiparametric
Density Testing in the Contamination Model.”</span> <em>Electronic
Journal of Statistics</em>, no. 13: 4743–93. https://doi.org/<a href="https://doi.org/10.1214/19-EJS1650" class="external-link">https://doi.org/10.1214/19-EJS1650</a>.
</div>
<div id="ref-Schwarz_1978" class="csl-entry">
Schwarz, G. 1978. <span>“Estimating the Dimension of a Model.”</span>
<em>The Annals of Statistics</em> 6 (2): 461–64.
</div>
<div id="ref-Xiang19" class="csl-entry">
Xiang, Yao, S., and G. Yang. 2018. <span>“An Overview of Semiparametric
Extensions of Finite Mixture Models.”</span> <em>Statistica Scinica</em>
34: 391–404.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Xavier Milhaud.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
